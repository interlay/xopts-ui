XFlash Protocols
================

.. _mint-protocol:

Mint 
-----

Pre-conditions
..............

Alice has 10 ``BTC`` on Bitcoin (i.e., locked in an UTXO controlled by her). Alice is identified by a public/private key pair :math:`pk_A, sk_A`. We assume, for simplicity, Alice uses the same key pair on both Bitcoin and Ethereum.
(Optional: Alice can specify an alternate key pair on Ethereum by (i) providing an `OP_RETURN` containing an Ethereum `account`, signed by `sk_A`)


Protocol
........

1. Alice locally generates a recovery secret :math:``r``. 

2. Alice creates a timelocked UTXO, locking 10 ``BTC`` for period :math:`t`, e.g., 24h, by broadcasting (and hence including) a transaction :math:`T_A` on Bitcoin. Thereby, Alice can recover her ``BTC`` at any time by revealing :math:``r``.
 
   * :math:`T_A` has at least one output ("payment UTXO"), which locks 10 ``BTC`` under the following condition: :math:`(\sigma_A \land t_{now} > t) \lor (\sigma_A \land H(r))`, where :math:`\sigma_A` is the signature generated by :math:`sk_A`, :math:`t_{now}` denotes the current blockchain time, and :math:`H(r)` is the output of a secure hash function :math:`H()` on input :math:`r` (SHA256 in Bitcoin).  
   * That is, only Alice can spend these coins:

      a. after time :math:`t` by providing her signature,
      b.  `anytime` by providing the preimage :math:`r` to :math:`H(r)` and her signature. 
   * The timelock can thereby be expressed as a UNIX timestamp or in Bitcoin blocks and can be (i) absolute (e.g. block height 500 000) or (ii) relative (e.g. 144 blocks after :math:`TX_A` is included in the Bitcoin blockchain)  
   * The transaction can have more outputs, but only the first will be checked in XFlash and considered for minting ``flashBTC`` tokens.

3. Alice waits for :math:`k` Bitcoin blocks.

4. Alice submits an SPV proof for :math:`T_A` to the :ref:`pool-sc` on Ethereum by calling the :ref:`deposit` function.


  a) The :ref:`pool-sc` calls :ref:`btc-relay` to (i) verify the inclusion proof for :math:`T_A` and (ii) to parse the transaction and extract the timelock duration from the first UTXO (and the target  `account` specified in the second `OP_RETURN` output).

  b) Mints 10 ``flashBTC`` token to Alice's Ethereum account `in the Lending Pool contract` by calling the :ref:`mint` function in the :ref:`treasury`.

Post-conditions
...............

Alice controls 10 ``flashBTC`` on Ethereum.


.. note:: Alice can execute the Mint process as often as she likes. This will result in the creation of :math:`r_1, ..., r_n` recovery secrets and :math:`t_1, ..., t_n` (likely cascading) timelocks. The smart contract needs to exhibit an efficient mechanism to track the active balances of ``flashBTC`` and update the latter when necessary.

.. note:: There is likely no need for a complex crowdfunded minting on the Bitcoin side: we simply consider the entire XFlash balance as a liquidity pool. The more ``BTC`` you lock, the higher the fraction of the return you get, similar to a staking pool (we do not differentiate between "whose" ``flashBTC`` were actually used for flash loans).

Expire
-------

When ``flashBTC`` are minted, they are tracked with their expiration time :math:`t`. When the current time :math:`t_{now}` is within a *security delay* :math:`\delta` of  expiration time :math:`t` the minted tokens expire.

  * The delay parameter :math:`\delta` is necessity since the block generation rates in Bitcoin and Ethereum can "desychronize", that is Bitcoin can speed up or slow down in relation to Ethereum due to mining variance. We can only avoid this if we have cross-chain relative timelocks (WIP).

Pre-conditions
..............

There are :math:`B` total `flashBTC` locked in the Lending Pool contract. For example, we assume that :math:`B = 100`.
We also assume the following account balances in the :ref:`treasury`:

   * Alice: 10 ``flashBTC``
   * Bob: 50 ``flashBTC``
   * Carol: 40 ``flashBTC``


Protocol
.........

1. The :ref:`pool-sc` implicitly reduces the available balance for lending by the expired tokens. 

.. note:: A user can of course lock ``BTC`` in multiple stages, i.e., have multiple timelocked UTXOs in parallel. The simplest way to handle this on Ethereum is for a single *account* to control multiple balances in the :ref:`treasury`. This can be handled via an additional mapping tracking the timeouts for locked amounts of ``BTC`` per user.

Post-conditions
................

There are only 90 ``flashBTC`` left in the smart contract, Alice has regained full control over her ``BTC`` and can withdraw any earned ``ETH`` fees from the smart contract.

.. _flashloan-protocol:

FlashLoan
---------

Dave takes out a flash loan of ``flashBTC``.

.. note:: The total amount of available ``flashBTC`` is determined by the current time :math:`t_{now}`: only ``BTC`` locked on Bitcoin with a timelock :math:`t > t_{now} + \delta` count towards the total available ``flashBTC`` balance. 

Pre-conditions
..............

There are :math:`B` total `flashBTC` locked in the Lending Pool contract. For example, we assume that :math:`B = 100`.
We also assume the following account balances in the :ref:`treasury`:

   * Alice: 10 ``flashBTC``
   * Bob: 50 ``flashBTC``
   * Carol: 40 ``flashBTC``


Dave wishes to lend an amount :math:`L` of ``flashBTC``.
For simplicity, let us assume ``B = L`` in this example.

Protocol
........

1. Dave creates and deploys a flash loan contract inheriting the :ref:`xflash-sc`. This contract needs to have two functions:

   a. The `flashExecute()` function in Dave's contract calls the :ref:`flash-borrow` function in the :ref:`pool-sc`. Dave will receive :math:`L` ``flashBTC`` after executing this function. In turn, the `flash-lend` function calls the second function in Dave's contract.

   b. The `executeActions()` function in Dave's contract receives the amount :math:`L` requested through `flashLoan()` and will execute actions specified by Dave. This function will also return the flash-loan by the end of the transaction including a fee (see also step 3).

2. Dave executes the flash loan by calling the `flashLoan()` function in his deployed XFlash contract. Note that Dave needs to specify all the actions to be executed in the deployed contract in step 1.

3. Dave's XFlash contract returns :math:`L` ``flashBTC`` to the smart contract and pays a fee :math:`f` in ``ETH``.

   * :math:`f` could thereby be a function of `L`, i.e., the higher the flash loan, the higher the fee :math:`f`. Reasoning: more volume should result in higher profits as it scales the system. The more liquidity is available, the more profit users can make on arbitrage trades. 
   * Alternatively, we could also charge a percentage of the arbitrage trade revenue, e.g. 1%. This would incentivize user to lock more BTC in the contract, as this allows higher profit margins on arbitrage trades and hence higher ROI on locked BTC.
   * Optionally, there can be a minimum fee on taking out flash loans (although this defeats one of the main benefits for borrowers - "pay on success"). Can be temporarily introduced if not enough users are locking BTC due to low profit margins to boost liquidity.

4. The smart contract distributes :math:`f` among Alice, Bob and Carol proportional to their contributions of ``flashBTC``.


Post-conditions
...............

The ``flashBTC`` balances remain unchanged. 
Dave has earned on an arbitrage trade on Ethereum and hence Alice, Bob, and Carol have earned a fraction of :math:`f` each. If Dave lost, no fees were paid (except if there is a minimum fee).



Announced Withdraw 
------------------

Alice announces that she wishes to withdraw her ``BTC`` from XFLASH, ``flashBTC`` balance is liquidated, fees are paid out and only then Alice recovers her ``BTC`` on Bitcoin using the hash pre-image / recovery secret ``r``. Alice can do this anytime while ``BTC`` are locked.

Pre-conditions
..............
There are :math:`B` total `flashBTC` locked in the XFlash contact. For example, we assume that :math:`B = 100`.
We also assume the following account balances in the :ref:`treasury`:

   * Alice: 10 ``flashBTC``
   * Rest: 90 ``flashBTC``


Protocol
........

1. Alice calls :ref:`withdraw` in the :ref:`pool-sc` to announce that she wishes to withdraw ``BTC`` from the lock on Bitcoin, providing a list of secrets :math:`r_1, ..., r_n` for the UTXOs she wishes to liquidate.

    a. The :ref:`pool-sc` iterates over the list of given secrets and removes the corresponding :math:`W` ``flashBTC`` from Alice's balance in the :ref:`treasury`:, reducing the total balance of available ``flashBTC``. 

2. Alice uses the revealed secrets :math:`r_1, ..., r_n` to recover the :math:`W` ``BTC`` on Bitcoin -- whenever she wants. 

Post-conditions
...............
There are only 90 ``flashBTC`` left in the smart contract, Alice has regained full control over her ``BTC`` and can withdraw any earned ``ETH`` fees from the smart contract -- **before** time :math:`t`.


Instant Withdraw
-----------------
Alice instantly withdraws her  ``BTC`` on Bitcoin by spending from the hash lock of the UTXO of :math:`T_A`. 

Pre-conditions
..............
There are :math:`B` total `flashBTC` locked in the XFlash contact. For example, we assume that :math:`B = 100`.
We also assume the following account balances in the :ref:`treasury`:

   * Alice: 10 ``flashBTC``
   * Bob: 50 ``flashBTC``
   * Carol: 40 ``flashBTC``

Protocol
.........

1.  Alice uses secrets :math:`r_1, ..., r_n` to recover the :math:`W` ``BTC`` on Bitcoin, without prior announcement on Ethereum.


**Option A: Liquidate & Slash Earnings** 

2a. Bob, Carol or any other user observes the revealed :math:`r_1, ..., r_n` on Bitcoin and submit the secrets to the :ref:`pool-sc`. 

3a. The :ref:`pool-sc` iterates over the list of given secrets and removes the corresponding :math:`W` ``flashBTC`` from Alice's balance in the :ref:`treasury`:, reducing the total balance of available ``flashBTC``. 

4a. ``ETH`` fees :math:`f` earned by Alice, proportional to the withdraw amount :math:`W` in relation to Alice's total balance :math:`B_A`, i.e., :math:`f \cdot \frac{B_A}{W}`, are slashed and distributed among other participants, according to the standard fee distribution scheme.

**Option B: Recovery Mint & Transfer Earnings** 

2b. Bob (or Carol or any other user) observes the revealed :math:`r_1, ..., r_n` on Bitcoin.

3b. Bob locks :math:`L_B` ``BTC`` on Bitcoin (such that :math:`L_B \geq W`) in a "timelock & hash recovery" transaction :math:`T_B` (same as used in :ref:`mint-protocol`) with a timelock :math:`t_B`, such that :math:`t_B \geq max(t_1, ..., t_n)` (i.e., Bob's timelock must be greater or equal to the highest timelock of the UTXOs recovered by Alice).

.. note:: Bob can also execute this "recovery-mint" protocol separately for each recovered UTXO / revealed secret :math:`r_i | i \in \{1..m\}, m \leq n`, allowing him to split his ``BTC`` across more fine-grained timelocks :math:`t_{(B,1)} \geq t_1, ..., t_{(B,m)} \geq t_m` rather than a single, likely higher, timelock :math:`t_B \geq max(t_1, ..., t_m)`.

4b. Bob executes a so called "recover mint": Bob submits a transaction inclusion proof for :math:`T_B` alongside the secrets :math:`r_1, ..., r_n` revealed by Alice to the :ref:`recovery_mint` function in the :ref:`pool-sc`

5b. The :ref:`pool-sc` iterates over the list of given secrets and removes the corresponding :math:`W` ``flashBTC`` from Alice's balance in the :ref:`treasury`:, reducing the total balance of available ``flashBTC``. 

6b. ``ETH`` fees :math:`f` earned by Alice, proportional to the withdraw amount :math:`W` in relation to Alice's total balance :math:`B_A`, i.e., :math:`f \cdot \frac{B_A}{W}`, are slashed and allocated to Bob.

Post-conditions
...............
There are only 90 ``flashBTC`` left in the ref:`treasury`, Alice has regained full control over her ``BTC`` **before** time :math:`t`, **BUT** has lost the right to any earned fees. The fees are, e.g. distributed among other participants, depending on the executed scheme.



Extend 
------

Alice extends the timelock of her locked 10 BTC by renewing the timelock of :math:`TX_A` **before** :math:`t - \delta` by spending from the hash lock.

.. todo:: Write up. Comments below have already been incorporated. TODO: reduce number of on-chain ETH transactions.

.. warning:: Problem: we need to extend the timelock **before** time :math:`t`, but need to do this without enabling Alice to spend the BTC in a "burn" before time :math:`t`. TODO for @Alexei: figure out how to do this. 

.. note:: Dominik: That problem is solved when you don't have a burn function. If Alice does not extend, she is no longer part of the pool.

.. note:: Idea: ``burn`` transaction has an additional hash lock - revealed, anyone can use the hash-preimage to ``burn`` Alices *flashBTC* balance in the contract. The "burn" transaction thereby disburses any ETH fees earned by Alice among all honest participants. Caveat: Alice (and other BTC holders) must not be able to take out the ETH earning while the BTC lock is active - IMHO okay (similar to a savings contract). Nice side-effect: users can take out their coins **at any time** by spending from the hash lock on Bitcoin. If they announce this upfront, then they do not lose and earned fees (or only lose a fraction, to pay to the watchtower fees). **Main drawback**: needs some sort of watchtower watching the locked BTC account.

.. note:: Dominik: I think that puts a lot of burden on Alice and creates a dependency from Ethereum to Bitcoin. The beauty of the existing protocol was that there was no depdency from Ethereum to Bitcoin.

Pre-conditions
..............

There are :math:`B` total `flashBTC` locked in the XFlash contact. For example, we assume that :math:`B = 100`.
We also assume the following account balances in the :ref:`treasury`:

   * Alice: 10 ``flashBTC``
   * Bob: 50 ``flashBTC``
   * Carol: 40 ``flashBTC``


Protocol
........

.. note:: The extend protocol is a variation of the minting protocol.

1. Alice spends her previously locked UTXO with expirey at :math:`t_p` (used in the :ref:`deposit` function) and creates a new timelocked UTXO, locking 10 ``BTC`` for period :math:`t`, e.g., 24h, by broadcasting (and hence including) a transaction :math:`T_A` on Bitcoin
 
   * :math:`T_A` has at least one output, which locks 10 ``BTC`` under the following condition: :math:`\sigma_A \land t_{now} > t`, where :math:`\sigma_A` is the signature generated by :math:`sk_A`.  
   * That is, only Alice can spend these coins after time :math:`t` (can be expressed in a UNIX timestamp or in Bitcoin blocks) and can be (i) absolute (e.g. block height 500 000) or (ii) relative (e.g. 144 blocks after :math:`TX_A` is included in the Bitcoin blockchain)  
   * The transaction can have more outputs, but only the first will be checked in XFlash and considered for minting ``flashBTC`` tokens.

2. Alice waits for :math:`k` Bitcoin blocks.

3. Alice submits an SPV proof for :math:`T_A` to the :ref:`pool-sc` on Ethereum by calling the :ref:`extend` function at time :math:`t_{submit}`.


  a) The :ref:`pool-sc` calls :ref:`btc-relay` to (i) verify the inclusion proof for :math:`T_A` and (ii) to parse the transaction and extract the timelock duration from the first UTXO (and the target  `account` specified in the second `OP_RETURN` output).

  b) Checks if the time of submitting the proof :math:`t_{submit}` is within the time of the initially locked ``flashBTC``, i.e. :math:`t_{submit} \leq t_{p} - \delta`.
  
    i) If at the time of submission Alice's previously minted ``flashBTC`` have not expired, Alice's previously minted ``flashBTC`` are extended from :math:`t_p` to time :math:`t`. 
    ii) Else, mints 10 ``flashBTC`` token to Alice's Ethereum account `in the Lending Pool contract` by calling the :ref:`mint` function in the :ref:`treasury`.



Post-conditions
...............
There balance of 100 ``flashBTC`` remains unchanged.


.. note:: We could introduce an `auction` protocol: if Alice takes out her BTC before the timelock expires, any user on a first-come-first-served basis can flag this (submitting Alice's secret or an SPV proof) and locking the equivalent amount of BTC to claim all fees earned by Alice. 
